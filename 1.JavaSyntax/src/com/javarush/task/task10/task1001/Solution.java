package com.javarush.task.task10.task1001;

/* 
Задача №1 на преобразование целых типов
*/

public class Solution {
    public static void main(String[] args) {
        int a = 0;
        int b = (byte) a + 46;
        byte c = (byte) (a * b);
        double f = (char) 1234.15;
        /* Сужение дробного типа до целочисленного является более сложной процедурой. Она проводится в два этапа.

            На первом шаге дробное значение преобразуется в long, если целевым типом является long, или в int - в противном случае (целевой тип byte, short, char или int ). Для этого исходное дробное число сначала математически округляется в сторону нуля, то есть дробная часть просто отбрасывается.

            Например, число 3,84 будет округлено до 3, а -3,84 превратится в -3. При этом могут возникнуть особые случаи:

               -- 0f / 0 - если исходное дробное значение является NaN, то результатом первого шага будет 0 выбранного типа (т.е. int или long );
               -- f / 0 - если исходное дробное значение является положительной или отрицательной бесконечностью, то результатом первого шага будет, соответственно, максимально или минимально возможное значение для выбранного типа (т.е. для int или long );
               -- наконец, если дробное значение было конечной величиной, но в результате округления получилось слишком большое по модулю число для выбранного типа (т.е. для int или long ), то, как и в предыдущем пункте, результатом первого шага будет, соответственно, максимально или минимально возможное значение этого типа. Если же результат округления укладывается в диапазон значений выбранного типа, то он и будет результатом первого шага.

            На втором шаге производится дальнейшее сужение от выбранного целочисленного типа к целевому, если таковое требуется, то есть может иметь место дополнительное преобразование от int к byte, short или char.
        */

        /*  Минимальное и максимальное значение целочисленных примитивов при приведении -Бесконечноть (Float.NEGATIVE_INFINITY) и +Бесконечность (Float.POSITIVE_INFINITY)
            long: -9223372036854775808..9223372036854775807
            int: -2147483648..2147483647
            short: 0..-1
            char: 0..65535
            byte: 0..-1
        */
        long d = (char) (short) (a + f / c + b); //ввиду того, что в скобках получается +Бесконечность (POSITIVE_INFINITY) от деления float на 0, то при приведении её к short получаем -1. А чтобы из отрицательного short получить положительное число, приводим его к единственному всегда-положительному примитиву  - char
        System.out.println(d);
    }
}
